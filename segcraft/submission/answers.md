# Ответы на тестовое задание: SegCraft

## Задание 1. Вопросы заказчику

### 1) Понять процесс (As-Is)
- Как сейчас создаются вариации текстов под сегменты и форматы: кто участвует, где возникают очереди?
- Сколько в среднем времени уходит на первый пакет вариаций и сколько раундов правок до запуска?
- В каких каналах и форматах чаще всего запускаются тексты (Директ, Бизнес, SMM и др.)?
- Какие обязательные ограничения уже действуют: комплаенс, бренд-тон, стоп-слова?

### 2) Понять, нужен ли AI в этой задаче
- Какие части работы повторяются и могут быть стандартизированы (например, сегментные адаптации и укладка в лимиты)?
- Где критичен human-in-the-loop и финальное решение редактора/маркетолога?
- Какие ошибки AI считаются приемлемыми на этапе черновика, а какие блокируют использование?
- Какие артефакты важны на выходе: таблица, JSON, шаблон для A/B теста?

### 3) Решение «брать / не брать» (impact / feasibility / risk / adoption)
- **Impact:** какую экономию времени и сокращение итераций считаем достаточным эффектом пилота?
- **Feasibility:** хватает ли доступных входных данных, чтобы получать полезные тексты без интеграций с внутренними системами?
- **Risk:** какие юридические/репутационные риски нужно отсекать автоматически до согласования?
- **Adoption:** кто будет владельцем процесса в команде и как встроить инструмент в текущий workflow без сопротивления?

## Задание 2. Описание кейса

### Проблема, As-Is, To-Be
Маркетинговая команда регулярно адаптирует один и тот же оффер под разные сегменты и форматы. Сейчас это ручной процесс: занимает 60–120 минут на первый пакет, затем несколько кругов правок из-за тона, комплаенса и лимитов площадки.

Целевое состояние (To-Be): пользователь вводит базовый оффер, выбирает сегменты, формат и ограничения, после чего получает структурированную матрицу вариантов с триггерами, CTA, risk-метками и экспортом в CSV/JSON за 2–3 минуты.

### Как работает решение
SegCraft собирает `case bundle` из входа пользователя и библиотеки сегментов, отправляет его в LLM с требованием строгого JSON по схеме, валидирует ответ через Pydantic и отображает в UI как рабочую таблицу. Если JSON повреждён, выполняется один repair-запрос; если не удалось — включается fallback на mock output.

### Какие данные нужны
- Базовый текст/оффер.
- Контекст продукта и целевой аудитории.
- Выбранные сегменты и формат публикации.
- Ограничения и запреты (стоп-формулировки, комплаенс).
- Желаемый уровень вариативности и число вариантов на сегмент.

### Риски и ограничения
- Галлюцинации и слишком общие обещания при слабом входе.
- Нарушение запретов и комплаенса без явных ограничений.
- Превышение лимитов символов в коротких форматах.
- Риск переоценки AI как «автопилота» без редактора.

### Что в MVP
- Streamlit UI с сегментами, форматами, ограничениями и параметрами генерации.
- Structured output по схеме (segments, copies, risk flags, export hints).
- Mock mode без API-ключа.
- JSON validation + one-shot repair.
- Экспорт CSV/JSON + блоки summary/differences/questions.

### Как объяснить нетехническому заказчику
SegCraft не заменяет маркетолога. Он снимает рутинный слой: за минуты готовит несколько управляемых текстовых гипотез под разные аудитории, сразу в формате, удобном для тестов и согласования.

Практическая ценность: меньше ручного переписывания, меньше циклов правок и более быстрый запуск A/B тестов. Решение безопаснее обычного чат-бота, потому что результат строго структурирован, учитывает лимиты и помечает рискованные формулировки.

### Где может сломаться и как поддерживать
- На слабом брифе качество падает: нужен список уточняющих вопросов.
- На юридически чувствительных темах нужны усиленные правила и словари запретов.
- На длинных процессах согласования важен журнал версий и комментарии.
- Поддержка: периодический аудит сегментов, форматов и стоп-правил.

### Что делать для прод (3–5 шагов)
1. Добавить RAG по бренд-гайдам, policy и примерам согласованных текстов.
2. Внедрить автоматический policy-checker и систему приоритетов рисков.
3. Подключить интеграции (таблицы, таск-трекер, редакторские workflows).
4. Построить quality loop: данные о принятии/отклонении вариантов и ретренинг промптов.
5. Настроить ролевую модель доступа и аудит изменений для масштабирования.

### Ссылки на материалы в репозитории
- Приложение: `app.py`
- Презентация: `deck/`
- Примеры входов/выходов: `samples/`
- Сценарий демо: `submission/demo_script.md`
